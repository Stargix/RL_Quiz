<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RL Mario Quiz</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --bg-primary: #5c94fc;
  --bg-secondary: #ffffff;
  --bg-card: #fef6e8;
  --accent: #f83800;
  --accent-hover: #c82c00;
  --success: #c8e6c9;
  --success-text: #2e7d32;
  --error: #ffcdd2;
  --error-text: #c62828;
  --text-primary: #000000;
  --text-secondary: #525252;
  --border: #000000;
  --coin: #ffd700;
}

body {
  font-family: 'Press Start 2P', cursive;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  padding: 1rem;
  font-size: 12px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
  padding-bottom: 2rem;
}

.header {
  text-align: center;
  padding: 2rem 0;
  margin-bottom: 2rem;
  background: var(--bg-secondary);
  border: 4px solid var(--border);
  border-radius: 8px;
}

.header h1 {
  font-size: clamp(1rem, 3vw, 1.5rem);
  color: var(--accent);
  margin-bottom: 1rem;
  line-height: 1.6;
}

.header p {
  color: var(--text-secondary);
  font-size: clamp(0.5rem, 1.5vw, 0.65rem);
  line-height: 1.8;
}

.progress-container {
  background: var(--bg-secondary);
  border: 4px solid var(--border);
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1.5rem;
}

.progress-label {
  font-size: 0.6rem;
  margin-bottom: 0.5rem;
  text-align: center;
}

.progress-bar {
  background: #d0d0d0;
  border: 3px solid var(--border);
  height: 24px;
  position: relative;
  overflow: hidden;
}

.progress-fill {
  background: var(--coin);
  height: 100%;
  transition: width 0.3s ease;
  border-right: 3px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.5rem;
  color: var(--border);
}

.quiz-card {
  background: var(--bg-card);
  border: 4px solid var(--border);
  padding: clamp(1rem, 3vw, 2rem);
  box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.3);
  margin-bottom: 1.5rem;
}

.question-header {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
}

.question-number {
  background: var(--accent);
  color: white;
  padding: 0.5rem 0.8rem;
  border: 3px solid var(--border);
  font-size: clamp(0.5rem, 1.5vw, 0.65rem);
  box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
}

.multi-answer-tag {
  background: var(--coin);
  color: var(--border);
  padding: 0.4rem 0.7rem;
  border: 3px solid var(--border);
  font-size: clamp(0.45rem, 1.2vw, 0.55rem);
  box-shadow: 3px 3px 0 rgba(0, 0, 0, 0.3);
}

.question-text {
  font-family: 'Inter', sans-serif;
  font-size: clamp(0.9rem, 2vw, 1rem);
  line-height: 1.6;
  margin-bottom: 1.5rem;
  color: var(--text-primary);
  font-weight: 500;
}

.choices {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
}

.choice {
  background: var(--bg-secondary);
  border: 3px solid var(--border);
  padding: 0.8rem 1rem;
  cursor: pointer;
  transition: all 0.1s ease;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-family: 'Inter', sans-serif;
  font-size: clamp(0.85rem, 1.8vw, 0.95rem);
  line-height: 1.5;
  box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
  font-weight: 400;
}

.choice:hover:not(.disabled) {
  transform: translate(-2px, -2px);
  box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
}

.choice:active:not(.disabled) {
  transform: translate(2px, 2px);
  box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.2);
}

.choice-checkbox {
  width: 18px;
  height: 18px;
  border: 3px solid var(--border);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
  position: relative;
}

.choice.selected .choice-checkbox {
  background: var(--coin);
}

.choice.selected .choice-checkbox::after {
  content: '‚òÖ';
  color: var(--border);
  font-size: 0.7rem;
  position: absolute;
}

.choice.correct {
  background: var(--success);
  color: var(--success-text);
  border-color: var(--success-text);
}

.choice.correct .choice-checkbox {
  background: white;
  border-color: var(--success-text);
}

.choice.correct .choice-checkbox::after {
  content: '‚úì';
  color: var(--success-text);
  font-weight: bold;
}

.choice.wrong {
  background: var(--error);
  color: var(--error-text);
  border-color: var(--error-text);
}

.choice.wrong .choice-checkbox {
  background: white;
  border-color: var(--error-text);
}

.choice.wrong .choice-checkbox::after {
  content: '‚úó';
  color: var(--error-text);
}

.choice.disabled {
  cursor: not-allowed;
}

.button-group {
  display: flex;
  gap: 1rem;
  margin-top: 2rem;
  flex-wrap: wrap;
}

.btn {
  flex: 1;
  min-width: 150px;
  padding: 0.8rem 1.2rem;
  border: 4px solid var(--border);
  font-weight: 400;
  font-size: clamp(0.5rem, 1.5vw, 0.65rem);
  cursor: pointer;
  transition: all 0.1s ease;
  font-family: inherit;
  box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
  line-height: 1.6;
}

.btn-primary {
  background: var(--accent);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  transform: translate(-2px, -2px);
  box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
}

.btn-primary:active:not(:disabled) {
  transform: translate(2px, 2px);
  box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.2);
}

.btn-secondary {
  background: var(--bg-secondary);
  color: var(--text-primary);
}

.btn-secondary:hover:not(:disabled) {
  transform: translate(-2px, -2px);
  box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.3);
}

.btn-secondary:active:not(:disabled) {
  transform: translate(2px, 2px);
  box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.2);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

.score-card {
  background: var(--coin);
  border: 4px solid var(--border);
  padding: 2rem;
  text-align: center;
  box-shadow: 8px 8px 0 rgba(0, 0, 0, 0.3);
}

.score-card h2 {
  font-size: clamp(0.8rem, 2.5vw, 1.2rem);
  margin-bottom: 1.5rem;
  line-height: 1.6;
}

.score-number {
  font-size: clamp(1.5rem, 5vw, 3rem);
  margin: 1rem 0;
  color: var(--accent);
}

.score-message {
  font-size: clamp(0.6rem, 1.8vw, 0.8rem);
  line-height: 1.8;
  margin-top: 0.5rem;
}

.info-box {
  background: #fffacd;
  border: 3px solid var(--border);
  padding: 0.8rem;
  margin-top: 1rem;
  font-size: clamp(0.5rem, 1.4vw, 0.6rem);
  line-height: 1.8;
  box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
}

@media (max-width: 640px) {
  body {
    padding: 0.5rem;
    font-size: 10px;
  }
  
  .button-group {
    flex-direction: column;
  }
  
  .btn {
    min-width: 100%;
  }
  
  .quiz-card {
    padding: 1rem;
  }
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üçÑ RL MARIO QUIZ üçÑ</h1>
    <p>PRACTICE FOR YOUR<br>REINFORCEMENT LEARNING EXAM</p>
  </div>

  <div class="progress-container">
    <div class="progress-label">PROGRESS</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress">0%</div>
    </div>
  </div>

  <div class="quiz-card" id="quiz-container">
    <!-- Quiz content will be inserted here -->
  </div>
</div>

<script>
const questions = [
  {
    q: "Assume you have to train with RL techniques a robot on an assembly line that has to remove defective elements from a continuous belt. How will you define the reward function? Which long-term definitions of reward make sense with your definition of rewards?",
    opts: [
      "Positive reward for removing defective items, negative for removing good items, undiscounted infinite horizon",
      "Penalize every item left on belt, discounted with Œ≥=0.9",
      "Give +1 reward each timestep, episodic task",
      "Negative reward for every motor movement to minimize energy"
    ],
    correct: [0]
  },
  {
    q: "Mark the problems that can be represented as a standard MDP (Markovian Decision Process):",
    opts: [
      "Solving Atari Pong with actions being 4 buttons and input only the current frame",
      "Agent learning to play Go against a learning opponent that adapts to your strategy",
      "Agent learning to play Othello against a fixed program opponent with full board state",
      "All of the above"
    ],
    correct: [2]
  },
  {
    q: "Mark the true sentences:",
    opts: [
      "With only the V value function for each state, we can compute the greedy policy for V",
      "Greedification step can be applied to policies with continuous actions",
      "If a policy œÄ is greedy with respect to the value function for the equiprobable random policy, then it is an optimal policy",
      "From only the Q value function we can compute the greedy policy for Q"
    ],
    correct: [3]
  },
  {
    q: "Considering learning in the tabular case (without function approximation), select the true sentences:",
    opts: [
      "Q-learning obtains less biased estimations of Q(s,a) than Monte Carlo",
      "Monte Carlo is an on-policy method",
      "In practical cases the value of Œ± is equal for all states but it can decrease with learning experience",
      "Exceptionally, exploration probability of one action a in one state s can be set to zero when Q(s,a) < 0"
    ],
    correct: [1, 2]
  },
  {
    q: "Select the true sentences:",
    opts: [
      "n-steps policy learning is an off-policy learning method",
      "Off-policy learning is better than on-policy when there is a lot of stochasticity in the environment transitions",
      "When Œµ = 0, Q-learning and SARSA are the same algorithm",
      "SARSA with fixed Œµ-greedy exploration (Œµ > 0) in general does not learn the optimal policy for an MDP"
    ],
    correct: [2, 3]
  },
  {
    q: "Select the true sentences:",
    opts: [
      "A good property of linear FA for Monte Carlo in policy evaluation is that it ensures convergence to the optimal policy because there is only a global optimal",
      "Batch methods solve the problem of the moving target by computing the target not only for the current state but for a larger number of samples at each iteration",
      "DQN uses two copies of the DNN with different weights, one of them frozen during several experiences to solve the problem of moving target",
      "DQN does not need the property of Markovian transitions to converge because it generates a non-linear approximation"
    ],
    correct: [1, 2]
  },
  {
    q: "Select the true sentences:",
    opts: [
      "Looking at the results of Rainbow, it seems more useful the Dueling technique than the Prioritized Experience Replay technique",
      "A3C algorithm does not need a Replay Experience Buffer because using several workers we train the network with uncorrelated data",
      "In practice, A3C algorithm is faster than DQN because (working several agents in parallel) it generates more samples in the same time",
      "DQN is an off-policy method"
    ],
    correct: [1, 2, 3]
  },
  {
    q: "In one short line each: what is the Actor and the Critic?",
    opts: [
      "Actor: policy network that outputs action probabilities; Critic: network that estimates state value",
      "Actor: chooses loss function; Critic: does backpropagation",
      "Both are the same network with shared layers",
      "Actor: maximizes entropy; Critic: minimizes bias"
    ],
    correct: [0]
  },
  {
    q: "In Proximal Policy Optimization (PPO), the importance-sampling ratio r is used to:",
    opts: [
      "Measure similarity between old and new policy distributions",
      "Compute the discounted return",
      "Replace the need for a critic",
      "Increase exploration"
    ],
    correct: [0]
  }
];

let currentQuestion = 0;
let score = 0;
let selectedAnswers = [];
let answered = false;

const quizContainer = document.getElementById('quiz-container');
const progressBar = document.getElementById('progress');

function shuffle(array) {
  return array.map(a => [Math.random(), a]).sort((a, b) => a[0] - b[0]).map(a => a[1]);
}

const shuffledQuestions = shuffle([...questions]);

function updateProgress() {
  const progress = Math.round((currentQuestion / shuffledQuestions.length) * 100);
  progressBar.style.width = progress + '%';
  progressBar.textContent = progress + '%';
}

function loadQuestion() {
  answered = false;
  selectedAnswers = [];
  const q = shuffledQuestions[currentQuestion];
  
  updateProgress();
  
  const isMulti = q.correct.length > 1;
  
  quizContainer.innerHTML = `
    <div class="question-header">
      <span class="question-number">QUESTION ${currentQuestion + 1}/${shuffledQuestions.length}</span>
    </div>
    
    <div class="question-text">${q.q}</div>
    
    <div class="choices" id="choices"></div>
    
    <div class="button-group">
      <button class="btn btn-primary" id="check-btn" onclick="checkAnswer()" disabled>
        CHECK ANSWER
      </button>
      <button class="btn btn-secondary" id="next-btn" onclick="nextQuestion()" style="display:none;">
        NEXT ‚Üí
      </button>
    </div>
  `;
  
  const choicesContainer = document.getElementById('choices');
  const shuffledOpts = q.opts.map((opt, idx) => ({text: opt, index: idx}));
  
  shuffledOpts.forEach(opt => {
    const choice = document.createElement('div');
    choice.className = 'choice';
    choice.dataset.index = opt.index;
    choice.innerHTML = `
      <div class="choice-checkbox"></div>
      <span>${opt.text}</span>
    `;
    choice.onclick = () => selectChoice(opt.index);
    choicesContainer.appendChild(choice);
  });
}

function selectChoice(index) {
  if (answered) return;
  
  const choices = document.querySelectorAll('.choice');
  
  const choiceIndex = selectedAnswers.indexOf(index);
  if (choiceIndex > -1) {
    selectedAnswers.splice(choiceIndex, 1);
    choices.forEach(c => {
      if (parseInt(c.dataset.index) === index) {
        c.classList.remove('selected');
      }
    });
  } else {
    selectedAnswers.push(index);
    choices.forEach(c => {
      if (parseInt(c.dataset.index) === index) {
        c.classList.add('selected');
      }
    });
  }
  
  document.getElementById('check-btn').disabled = selectedAnswers.length === 0;
}

function checkAnswer() {
  if (answered) return;
  answered = true;
  
  const q = shuffledQuestions[currentQuestion];
  const choices = document.querySelectorAll('.choice');
  
  const correctSet = new Set(q.correct);
  const selectedSet = new Set(selectedAnswers);
  
  const isCorrect = correctSet.size === selectedSet.size && 
                    [...correctSet].every(x => selectedSet.has(x));
  
  if (isCorrect) score++;
  
  choices.forEach(c => {
    const idx = parseInt(c.dataset.index);
    c.classList.add('disabled');
    
    if (correctSet.has(idx)) {
      c.classList.add('correct');
    } else if (selectedSet.has(idx)) {
      c.classList.add('wrong');
    }
  });
  
  document.getElementById('check-btn').style.display = 'none';
  document.getElementById('next-btn').style.display = 'block';
}

function nextQuestion() {
  currentQuestion++;
  
  if (currentQuestion < shuffledQuestions.length) {
    loadQuestion();
  } else {
    showResults();
  }
}

function showResults() {
  const percentage = Math.round((score / shuffledQuestions.length) * 100);
  let message = '';
  
  if (percentage >= 90) message = 'EXCELLENT! YOU ARE A SUPER STAR!';
  else if (percentage >= 70) message = 'GREAT JOB! KEEP IT UP!';
  else if (percentage >= 50) message = 'GOOD! PRACTICE MORE!';
  else message = 'GAME OVER! TRY AGAIN!';
  
  quizContainer.innerHTML = `
    <div class="score-card">
      <h2>STAGE COMPLETE!</h2>
      <div class="score-number">${score}/${shuffledQuestions.length}</div>
      <div class="score-message">${message}</div>
      <div class="score-message" style="margin-top: 1rem;">SCORE: ${percentage}%</div>
    </div>
    
    <div class="button-group" style="margin-top: 2rem;">
      <button class="btn btn-primary" onclick="restart()">üîÑ RESTART GAME</button>
    </div>
  `;
  
  progressBar.style.width = '100%';
  progressBar.textContent = '100%';
}

function restart() {
  currentQuestion = 0;
  score = 0;
  selectedAnswers = [];
  answered = false;
  shuffledQuestions.length = 0;
  shuffledQuestions.push(...shuffle([...questions]));
  loadQuestion();
}

// Initialize
loadQuestion();
</script>
</body>
</html>
